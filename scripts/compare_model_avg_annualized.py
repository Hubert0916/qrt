"""Generate window-by-model annualized return summary tables."""

from __future__ import annotations

import argparse
from pathlib import Path
from typing import Optional

import pandas as pd

from experiments import benchmark_core


def parse_model_order(raw: Optional[str]) -> Optional[list[str]]:
    if raw is None:
        return None
    order = [name.strip() for name in raw.split(",") if name.strip()]
    return order or None


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description=(
            "Aggregate annualized return by window for each model and export as CSV."
        )
    )
    parser.add_argument(
        "--metrics",
        type=Path,
        required=True,
        help="Path to metrics.csv generated by benchmark runs.",
    )
    parser.add_argument(
        "--outdir",
        type=Path,
        default=None,
        help="Directory for the output CSV (defaults to metrics parent directory).",
    )
    parser.add_argument(
        "--filename",
        type=str,
        default="annualized_return_by_model.csv",
        help="Name for the exported CSV file.",
    )
    parser.add_argument(
        "--model-order",
        type=str,
        default=None,
        help="Comma separated list to set column ordering (others will follow).",
    )
    parser.add_argument(
        "--float-format",
        type=str,
        default="%.6f",
        help="Format string for floating point export.",
    )
    return parser


def main(argv: Optional[list[str]] = None) -> None:
    parser = build_parser()
    args = parser.parse_args(argv)

    if not args.metrics.exists():
        parser.error(f"Metrics file not found: {args.metrics}")

    df = pd.read_csv(args.metrics)
    required_cols = {"window", "model", "annualized_return"}
    missing_cols = required_cols.difference(df.columns)
    if missing_cols:
        parser.error(
            f"Metrics file is missing required columns: {', '.join(sorted(missing_cols))}"
        )

    try:
        summary = benchmark_core.annualized_return_by_model(
            df, model_order=parse_model_order(args.model_order)
        )
    except ValueError as exc:
        parser.error(str(exc))

    if summary.empty:
        parser.error("Metrics file contains no annualized return records.")

    outdir = args.outdir or args.metrics.parent
    outdir.mkdir(parents=True, exist_ok=True)
    outfile = outdir / args.filename
    summary.to_csv(outfile, float_format=args.float_format)

    print(f"Saved aggregated table to {outfile}")


if __name__ == "__main__":  # pragma: no cover
    main()
